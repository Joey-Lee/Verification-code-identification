# Verification-code-identification
Verification code identification using Python  
##前言
做这件事的起因是因为每天都要在一个微信公众号上签到，于是本着“让一切自动化”的精神，打算写一个python脚本，实现这个功能。一开始因为一直都是在手机上操作，所以考虑怎么写个脚本能在手机上运行，想了一圈，无果扑街。。后来发现其实这不就是一个链接么，于是复制链接在电脑浏览器上打开，果然没有问题！于是，就开始了这个“项目”。<br>
##遇到问题
由于有前两个[爬虫](https://github.com/shenmilanzi/small-tool)的经验，很快就写好了大部分代码，但是突然发现事情好像没那么简单——网页上的验证码怎么识别？<br>
以往的经验是遇到验证码要么让程序暂停几秒，然后再手动输入；要么就是遇到验证码就将它立即识别出来再返回到浏览器，实现登陆。第一种方法的成功率自然是100%，但是就不再是“自动”了。所以我选择第二种方法，顺便算是挑战一下。<br>
##分析问题  
首先，我找到了验证码图片的链接，于是就顺手写了几行代码，爬出了500张验证码图片保存到本地用作分析。通过观察，我需要识别的验证码图片样式统一，都是由0~9十个数字的组合，另外背景为不同的颜色还增加了一些雪花和干扰线。看上去好像很简单，但是要怎样才能让计算机知道图片中的数字呢？<br>
##解决问题
###1）pytesser3
稍微google了一下，发现有现成开源的工具pytesse(OCR in Python using the Tesseract engine from Google。是谷歌OCR开源项目的一个模块，可将图片中的文字转换成文本（主要是英文）)。捣鼓了半天，主要是安装tesseract-OCR引擎，费了番功夫安装好后，迫不及待满怀期待地试了下，结果几乎识别不出。考虑到我试验的图片并没有做处理，就是原始图片直接扔进去识别，所以怀疑是不是图片的问题。之前也没有接触过图像处理方面的东西，就简单照着网上的代码，调了图片的灰度、对比度增强，再拿去做识别发现还是不理想，所以最终放弃了这个工具。<br>
###2）cookies
看到一篇技术博客，说利用网站cookie可以绕开验证码直接登陆。怀着试一试的想法，我也试过这一方法，利用抓包工具查看cookies，在模拟登陆时加入相应的cookies，但是发现每次登陆cookies是不一样的。最后这一尝试也宣告失败。
###3）SVM
####2.1 图片预处理
原始验证码图片已经有了，于是首先需要对这些图片做预处理。先将彩色图片转为灰度图，再增加了图像的锐度，使图像更加清晰，最后再将图片二值化为黑白图。如图![](https://github.com/shenmilanzi/Verification-code-identification/blob/master/01.png)。此时的图片为黑白图，背景的雪花因为本身为浅色，初步处理后已经消除的比较干净了，只是还残留干扰线。干扰线的处理方法参考了这篇[博客](http://www.cnblogs.com/beer/p/5672678.html)。写好了del_noise(img)函数后，将初步处理的图片传入函数，发现效果“特别特别好”！（当晚非常激动！！）处理干扰线后的图片像这样![](https://github.com/shenmilanzi/Verification-code-identification/blob/master/8-3.png)。这两个图片都是经过图片切割之后的。因为我遇到的验证码里面的数字都分得很开，直接找到每个数字所在的区域做一下切割就好了。
####2.2 人工标记
这一步的目的是为0~9每一个数字都建立一个素材库，作为训练数据或者比较的标准。具体操作就是对处理切割后的图片（大约1000张）做人工识别、分类。最后每一类中的图片大约70~80张左右不等，无需多言。
####2.3 kNN
做到这里，本来应该建立SVM模型训练模型了，但是之前也没有用过sklearn工具包，也有一个学习的过程。但是我突然有了一个简单的方法，我只需要把待识别的图片与素材库里的所有图片比较一遍，找出最相似的那一类作为识别结果不就对了吗？<br>
这差不多是kNN的思想。前段时间刚好看了一些数据挖掘的东西，里面的推荐算法好像正好可以用上。每张图片都是一个矩阵，矩阵不就是向量吗，我只需要计算一下两张图片的余弦相似度，找出余弦值最大的就好，好像很简单的样子。直接实现，很快就写出了kNN_indentifier(img)这个函数，发现结果并不对。输入不同的待识别图片，输出的结果都是“0000”，打印出最相似的素材库的图片，发现居然每次都相同。这肯定是哪里出了问题，但是这个思想应该是没什么问题的。进一步查找问题，发现问题出在用numpy打开二值化后的图片矩阵中的元素为bool型，并不是0、1数值型。于是将dtype的bool型转化为int8型，结果不再是“0000”，但还是不对。<br>
识别结果还是不理想，我反复思考，觉得这不应该是方法的问题。于是就换了一种判断相似的算法，通过比较两个矩阵的欧式距离，距离越小越相似。计算两矩阵欧式距离的代码更简单，一行就写出了。对待识别图片，分别与每一类中的所有图片计算欧式距离，记录这一类中最相似的图片和相应的欧式距离。然后再将10个欧式距离做一个排序，最小的那个即为识别的结果。嘿，效果竟然特别特别好！（又是一阵相当激动！！）
####2.4 SVM
用了一种方法解决了这个问题自然还不够，不是还没用“高大上”的机器学习吗。我准备再尝试下用SVM来解决这一问题。SVM的基本原理我大概知道一点，但是这里偏向于解决实际问题，也就不深究一些细节了，直接利用sklearn里的SVM类。选择好图像特征，和那博客中的类似，记录下每张图片每一行和每一列中“黑点”的个数，图片都是27 * 50像素，一共77维。这里也没有考虑维数对计算量的影响。获取训练样本和标签后就可以训练模型了。模型训练好，再把待识别图片的特征输入做预测。最终识别结果不如kNN那种方法。<br>
###思考
见[备注.txt](https://github.com/shenmilanzi/Verification-code-identification/blob/master/%E5%A4%87%E6%B3%A8.txt)
###鸣谢
感谢一切开源的大牛和前辈，特别感谢那篇博客的作者哈莫！
